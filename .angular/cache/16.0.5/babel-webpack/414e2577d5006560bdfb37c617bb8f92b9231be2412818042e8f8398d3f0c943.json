{"ast":null,"code":"import { from, Observable, EMPTY } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n/**\n * Lazy loads Firebase Performance monitoring and returns the instance as\n * an observable\n * @param app\n * @returns Observable<FirebasePerformance>\n */\nvar getPerformance$ = function (app) {\n  return from(import('firebase/performance').then(function (module) {\n    return module.getPerformance(app);\n  }));\n};\n/**\n * Creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param traceId\n * @returns Observable<void>\n */\nvar trace$ = function (traceId) {\n  if (typeof window !== 'undefined' && window.performance) {\n    var entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n    var startMarkName_1 = \"_\" + traceId + \"Start[\" + entries.length + \"]\";\n    var endMarkName_1 = \"_\" + traceId + \"End[\" + entries.length + \"]\";\n    return new Observable(function (emitter) {\n      window.performance.mark(startMarkName_1);\n      emitter.next();\n      return {\n        unsubscribe: function () {\n          window.performance.mark(endMarkName_1);\n          window.performance.measure(traceId, startMarkName_1, endMarkName_1);\n        }\n      };\n    });\n  } else {\n    return EMPTY;\n  }\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar trace = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until\n * a condition resolves to true and then the observable unsubscribes and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntil = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function (a) {\n        return test(a) && traceSubscription.unsubscribe();\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs while\n * a condition resolves to true. Once the condition fails the observable unsubscribes\n * and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceWhile = function (name, test, options) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription;\n      return source$.pipe(tap(function (a) {\n        if (test(a)) {\n          traceSubscription = traceSubscription || trace$(name).subscribe();\n        } else {\n          if (traceSubscription) {\n            traceSubscription.unsubscribe();\n          }\n          traceSubscription = undefined;\n        }\n      }, function () {}, function () {\n        return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until the\n * observable fully completes.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilComplete = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {}, function () {}, function () {\n        return traceSubscription.unsubscribe();\n      })).subscribe(subscriber);\n    });\n  };\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given name.\n * The trace runs until the first value emits from the provided observable.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilFirst = function (name) {\n  return function (source$) {\n    return new Observable(function (subscriber) {\n      var traceSubscription = trace$(name).subscribe();\n      return source$.pipe(tap(function () {\n        return traceSubscription.unsubscribe();\n      }, function () {}, function () {})).subscribe(subscriber);\n    });\n  };\n};\nexport { getPerformance$, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };","map":{"version":3,"names":["from","Observable","EMPTY","tap","getPerformance$","app","then","module","getPerformance","trace$","traceId","window","performance","entries","getEntriesByName","startMarkName_1","length","endMarkName_1","emitter","mark","next","unsubscribe","measure","trace","name","source$","subscriber","traceSubscription","subscribe","pipe","traceUntil","test","options","a","orComplete","traceWhile","undefined","traceUntilComplete","traceUntilFirst"],"sources":["C:/Users/55219/Desktop/Studio-Val-em-conclusao/node_modules/rxfire/performance/index.esm.js"],"sourcesContent":["import { from, Observable, EMPTY } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n/**\n * Lazy loads Firebase Performance monitoring and returns the instance as\n * an observable\n * @param app\n * @returns Observable<FirebasePerformance>\n */\nvar getPerformance$ = function (app) { return from(import('firebase/performance').then(function (module) { return module.getPerformance(app); })); };\n/**\n * Creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param traceId\n * @returns Observable<void>\n */\nvar trace$ = function (traceId) {\n    if (typeof window !== 'undefined' && window.performance) {\n        var entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n        var startMarkName_1 = \"_\" + traceId + \"Start[\" + entries.length + \"]\";\n        var endMarkName_1 = \"_\" + traceId + \"End[\" + entries.length + \"]\";\n        return new Observable(function (emitter) {\n            window.performance.mark(startMarkName_1);\n            emitter.next();\n            return {\n                unsubscribe: function () {\n                    window.performance.mark(endMarkName_1);\n                    window.performance.measure(traceId, startMarkName_1, endMarkName_1);\n                }\n            };\n        });\n    }\n    else {\n        return EMPTY;\n    }\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar trace = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () { return traceSubscription.unsubscribe(); }, function () {\n    }, function () { return traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until\n * a condition resolves to true and then the observable unsubscribes and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntil = function (name, test, options) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function (a) { return test(a) && traceSubscription.unsubscribe(); }, function () {\n    }, function () { return options && options.orComplete && traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs while\n * a condition resolves to true. Once the condition fails the observable unsubscribes\n * and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceWhile = function (name, test, options) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription;\n    return source$.pipe(tap(function (a) {\n        if (test(a)) {\n            traceSubscription = traceSubscription || trace$(name).subscribe();\n        }\n        else {\n            if (traceSubscription) {\n                traceSubscription.unsubscribe();\n            }\n            traceSubscription = undefined;\n        }\n    }, function () {\n    }, function () { return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until the\n * observable fully completes.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilComplete = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () {\n    }, function () {\n    }, function () { return traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name.\n * The trace runs until the first value emits from the provided observable.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilFirst = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () { return traceSubscription.unsubscribe(); }, function () {\n    }, function () {\n    })).subscribe(subscriber);\n}); }; };\n\nexport { getPerformance$, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}